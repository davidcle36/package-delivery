1.  Explain the algorithmâ€™s logic using pseudocode.

    * Same as in main.py

    ---------------------------------------------------

        The algorithm comprise three components, the data structure, sorting and
        then traversal.

        Graph Data Structure:

               After a Hash Table has been built for each location and the respective miles as vertex. Then when added to graph, each
            vertex has a label, and a list of miles from that vertex to others. Knowing the distance between
            point A to point B, a weighted(undirected) graph can be created.

            #######
            #
            # File: /Graph.py, /utils.DrawGraph
            #
            # Classes: Graph, Vertex
            #
            #
            ######

            Building an undirected graph:
                Class: Graph

                    Using a hash table, with the key being the address, and the values
                    being the edge's weight between it and the many vertices. It provides the
                    time complexity of O(1) when searching, or updated by address.(Zybook, 2013)

                    Another hash table that is initialize is edge_weights, which holds the value of between two points given
                    the time complexity of O(1) when searching (address A, address B).

                    The time complexity to build undirected graph is N + (N * N) = O(N * N)
                    The space complexity is O(V + E) where V are the vertices and E are the edge's weights

                    ** B.2 Detailed description, and how space and time complexity was arrived is in /Graph.py

                    Pseudocode:
                    ################################

                    def Build_Graph(self):
                        locations = [...Location]
                        adjacency_list = HashMap(S) // S is number of locations
                        edge_weights = HashMap(M)   // M is the number pair of vertex

                        For each Location in locations:
                            Add Vertex to adjacency_list

                        i += 1
                        For each vertex_a in adjacency_list:
                            while i < len(adjacency_list):
                              if edge:
                                vertex_b = adjacency_list.get(key of adjacency_list i)      // O(1)
                                edge_weights.insert((vertex_a, vertex_b), vertex_b.weight)  // O(1)
                                edge_weights.insert((vertex_b, vertex_a), vertex_b.weight)  // O(1)
                                adjacency_list.update(vertex_a, [from vertex_a : to vertices adjacent of vertex_a,
                                    vertex_b -> vertex_N*]) // O(1 + K), where K is the number of collision
                                adjacency_list.update(vertex_b, [from vertex_b : to vertices adjacent of vertex_b,
                                    vertex_a -> vertex_N*]) // O(1 + K), where K is the number of collision
                            i += 1

                    ################################


                    Class Graph's Methods
                    -----------------------------
                    Add_Vertex(self, String address, [] adjacent miles of address)
                        Time Complexity: O(N)

                        Pseudocode:
                        ##############################

                        ...
                        For each Location in locations:
                            Add Vertex to adjacency_list
                        ...

                        ##############################



                    Add_Undirected_Edge(self)
                        Input: vertex A, Vertex B that is adjacent to A, and the edge weight between them
                        Time Complexity: 5(1) * N * N = O(N * N)

                        Pseudocode:
                        ##############################

                        ...
                        For each vertex_a in adjacency_list:    // O(N)
                            while i < len(adjacency_list):      // O(N)
                              if edge:
                                vertex_b = adjacency_list.get(key of adjacency_list i)      // O(1)
                                edge_weights.insert((vertex_a, vertex_b), vertex_b.weight)  // O(1)
                                edge_weights.insert((vertex_b, vertex_a), vertex_b.weight)  // O(1)
                                adjacency_list.update(vertex_a, [from vertex_a : to vertices adjacent of vertex_a,
                                    vertex_b -> vertex_N*]) // O(1 + K), where K is the number of collision
                                adjacency_list.update(vertex_b, [from vertex_b : to vertices adjacent of vertex_b,
                                    vertex_a -> vertex_N*]) // O(1 + K), where K is the number of collision
                        ...

                        ##############################


        Dijkstra's shortest path Traversal:

                The algorithm computes the shortest path from the initial given vertex to all other
            vertices in the graph. Two data members are required in the vertex are the total distance
            from start to another vertex. Also, reference to the previous vertex.

                The Dijkstra shortest path is somewhat similar as a link list, where one points directly to address,
            and the it is object of an instance. But essentially the same thing. It is like a link list but the link
            carries weight as the vertex connect to its adjacent vertices. As for this program, it is the distance.
            The time complexity of Dijkstra shortest path O(|V| * |E| log |E|) where V is the number of vertices,
            and E is number of edge's weight between vertices. Since the further away from starting point, the greater amount of
            adjacent vertex connect to it, and vice versa. For examples, starting vertex, V, is equal to N vertices
            adjacent to it. For the number of edges, between some vertex_a* and another vertex_b*, an edge must exist,
            and worst case, one travel through all the edges to get to target, O(LogE) times. And in the end, the value
            holding the smallest index is pop, which added E times to the algorithms since it might need to pop the first index
            and then shift the array over by one. Thus making it O(|E| + |V| log |V|) (GeeksforGeeks, 2020)

                But with a hash table, a shifting is not a problem since each items are placed in a bucket. Thus, in the codebase
            for dijkstra_shortest_path time complexity is O(|V| + Log |E|) since the hash function remove smallest index
            takes O(1 + M) or O(1) without the need to shift the list over, and M is  number of collision in the hash table.

                The space complexity is O(|V| + |E|), where V is the number of vertices, and E is the number of edges

            ** B.2 Detailed description, and how space and time complexity was arrived in /utils.Dijkstra.py

            Pseudocode
            ################################
                # (Zybook, 2013)
                def dijkstra_shortest_path(Graph graph, Vertex vertex_a):
                    unvisited_queue = []


                    # Placed all locations in the unvisited_queue[]
                    # Time Complexity is O(N*N)

                    for each vertices in locations[0 -> N]:
                        for each vertex in vertices:
                            if vertex.adjacent[0 -> N] is not None:
                                Add vertex to unvisited Queue

                    Set the distance of starting vertex = 0

                    # Find the smallest distance between between vertex_a and another vertex.
                    # Linked the found vertex to the previous vertex
                    #
                    # It works similar to a linked list as each vertex has a previous vertex,
                    # and the head previous is none, which conclude the route. So from the last
                    # of the list, it is possible to trace back to the beginning.
                    #
                    # Example:
                    #       3th st -> 2nd st -> 1st st -> None, when 1st st is the starting point.

                    while unvisited_queue is not empty:
                        smallest_index = 0
                        for each item in unvisited_queue[0 -> N]:
                            if item.distance < item[smallest_index].distance then
                                smallest index = indexOf(item)
                        current_vertex = unvisited_queue.pop(smallest_index)


                        for each adjacent vertex from current_vertex:
                            weight = from current to adj vertex
                            total_distance_between = current distance + weight

                            if short path is found from current to another adjacent vertex:
                                adj distance = total_distance_between
                                adj vertex -> prev = current vertex




            ################################





        Edge's Weight Comparison Sorting:

                After building an undirected graph, a method can be used to compared the distance between
            vertex_a and vertex_b to find the minimum, and break them into list of package ids. The package ids
            would call a getter to get in instance of that Package, thus, getting the address, notes, time, etc.

                For the Edge's weight comparison, the codebase would use two package addresses to get the distance
            between them from the hash table, Graph.edge_weights. The key to search for the distance between the vertex
            is a tuple(vertex_a, vertex_b), which was already set up when the undirected graph was built. Since the
            max packages per truck, the sorted route list will be at max 16.

            The Time complexity is O(N^3 * log |E|)
            The space complexity is O(V + E)

            * As I was having problem sorting it, I have to manually count how much packages a truck can get at a time,
              and the special notes condition as much as I could without going over 140 miles while fulfilling deadline.

            ** B.2 Detailed description, and how space and time complexity was arrived in /Truck.py

                Pseudocode:
                ################################

                def sort_by_distance(self, HashMap hash_table_package, String packages_ids[],
                                        int max_load_in_truck)
                    packages_in_truck = []
                    min_weight = float("inf")
                    current_address = "HUB"
                    end_address = ""
                    picked_package = ""

                    # Loop through the entire packages and get every possible weight between two vertices and return only
                    # the shortest path v1 <--> v2 <--> v2 ... vN <--> vN - 1 through dijkstra_shortest_path algorithm

                    while i < length of package_ids[]:
                        dijkstra_shortest_path(graph, hash_table_package[vertex_a])
                        weight = float("inf")

                        # For each vertex, get the minimum between starting vertex_a and vertex_K, where k
                        # can be vertex 1 to N

                        for each vertices in adjacency_list:
                            for each current_vertex in vertices:
                                if current_vertex is vertex_a:
                                    weight = Dijkstra's shortest path between current and vertex a

                        if weight < min_weight
                                and package_id not in packages_in_truck
                                and packages_in_truck < max_load_in_truck:
                            min_weight = weight[i]
                            end_address = vertex_b address
                            picked_package = packages_ids[i]

                        Add picked_package to packages_in_truck
                        current_address = end_address
                        i++

                    return packages_in_truck

                def sort_packages(self, HashMap hash_table_package , String package_ids[]):
                    max_load_in_truck = single value from 1 -> N When N is less than or equal to 16


                    packages_in_truck = sort_by_distance(self, hash_table_package, package_ids, length(packages_ids))
                    sorted_packages_in_truck_Trip_1 = sort_by_distance(self, hash_table_package,
                                                                    package_ids[0 -> max_load_in_truck], max_load_in_truck)

                    leftover_packages = packages_in_truck[] - sorted_packages_in_truck_Trip_1[]
                    ...

                    sorted_packages in truck_Trip_N = ...


                    return sorted_packages_in_truck_trip (1 -> N)

        Conclusion of B.1 ------------------------------------- -------------------------------------
